package com.skannamu.client;

import com.skannamu.network.ExploitTriggerPayload;
import net.fabricmc.fabric.api.client.networking.v1.ClientPlayNetworking;
import net.fabricmc.fabric.api.networking.v1.PacketByteBufs;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.network.ClientPlayerEntity;
import net.minecraft.client.sound.PositionedSoundInstance;
import net.minecraft.client.sound.SoundManager;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.network.PacketByteBuf;
import net.minecraft.sound.SoundEvents;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.MathHelper;
import java.util.UUID;

public class ClientExploitManager {

    private static SequenceState currentState = SequenceState.INACTIVE;
    private static long startTick = 0;
    private static int durationTicks = 0;
    private static UUID currentTargetUuid = null;
    private static float originalPitch = 0.0f;
    private static float smoothCameraPitch = 0.0f;

    private static final Identifier EXPLOIT_TRIGGER_ID = Identifier.of("skannamu", "exploit_trigger");

    private static boolean isLmbDown = false;
    private static int lmbHoldTicks = 0;
    private static final int TRIGGER_HOLD_DURATION = 50;
    private static final int TARGETING_END_TICK = 50;
    private static final int FADE_OUT_1_END_TICK = 60;
    private static final int ATTACK_END_TICK = 80;
    private static final int FADE_OUT_2_END_TICK = 90;
    private static final int SEQUENCE_END_TICK = 100;

    public enum SequenceState {
        INACTIVE,
        TARGETING,
        WAITING_FOR_TRIGGER,
        FADE_TO_ATTACK,
        ATTACK_PHASE,
        FADE_TO_RETURN,
        FADE_FROM_RETURN,
        WAIT_FOR_UNLOCK
    }

    public static void startSequence(UUID targetId, int duration) {
        MinecraftClient client = MinecraftClient.getInstance();
        ClientPlayerEntity player = client.player;
        ClientWorld world = client.world;

        if (player != null && world != null) {
            startTick = world.getTime();
            durationTicks = duration;
            currentTargetUuid = targetId;
            originalPitch = player.getPitch();
            smoothCameraPitch = originalPitch;
            lmbHoldTicks = 0;
            isLmbDown = false;
            currentState = SequenceState.TARGETING;

            SoundManager soundManager = client.getSoundManager();
            soundManager.play(PositionedSoundInstance.master(
                    SoundEvents.BLOCK_REDSTONE_TORCH_BURNOUT, 1.0F, 1.0F
            ));

            if (client.currentScreen != null && client.currentScreen.getTitle().getString().contains("Terminal")) {
                client.setScreen(null);
            }
        }
    }

    public static void setLmbDown(boolean pressed) {
        isLmbDown = pressed;
    }

    public static void clientTick(MinecraftClient client) {
        if (currentState == SequenceState.INACTIVE) return;

        ClientWorld world = client.world;
        ClientPlayerEntity player = client.player;
        if (world == null || player == null) {
            endSequence();
            return;
        }

        long currentTick = world.getTime();
        int elapsedTicks = (int) (currentTick - startTick);

        if (currentState == SequenceState.TARGETING) {
            if (elapsedTicks >= TARGETING_END_TICK) {
                currentState = SequenceState.WAITING_FOR_TRIGGER;
            } else {return;}
        }

        if (currentState == SequenceState.WAITING_FOR_TRIGGER) {
            if (isLmbDown) {
                lmbHoldTicks++;
            } else {
                lmbHoldTicks = 0;
            }

            if (lmbHoldTicks >= TRIGGER_HOLD_DURATION) {
                if (client.player != null && currentTargetUuid != null) {
                    ExploitTriggerPayload payload = new ExploitTriggerPayload(client.player.getUuid(), currentTargetUuid);
                    ClientPlayNetworking.send(payload);
                }
                startTick = currentTick - TARGETING_END_TICK;
                currentState = SequenceState.FADE_TO_ATTACK;
                lmbHoldTicks = 0;
            }
            else {
                return;
            }
        }

        elapsedTicks = (int) (currentTick - startTick);

        if (elapsedTicks < FADE_OUT_1_END_TICK) {
            currentState = SequenceState.FADE_TO_ATTACK;
        } else if (elapsedTicks < ATTACK_END_TICK) {
            currentState = SequenceState.ATTACK_PHASE;
        } else if (elapsedTicks < FADE_OUT_2_END_TICK) {
            currentState = SequenceState.FADE_TO_RETURN;
        } else if (elapsedTicks < SEQUENCE_END_TICK) {
            currentState = SequenceState.FADE_FROM_RETURN;
        } else {
            currentState = SequenceState.WAIT_FOR_UNLOCK;
        }

        if (currentState == SequenceState.ATTACK_PHASE) {
            if (player.hurtTime < 9) {
                player.hurtTime = 9;
                player.maxHurtTime = 9;
            }
        }
    }

    public static void endSequence() {
        currentState = SequenceState.INACTIVE;
        startTick = 0;
        durationTicks = 0;
        currentTargetUuid = null;
        lmbHoldTicks = 0;
        isLmbDown = false;
    }

    public static float getFadeAlpha() {
        if (currentState == SequenceState.INACTIVE || currentState == SequenceState.WAITING_FOR_TRIGGER || currentState == SequenceState.WAIT_FOR_UNLOCK) return 0.0f;

        MinecraftClient client = MinecraftClient.getInstance();
        if (client.world == null) return 0.0f;

        long currentTick = client.world.getTime();
        int elapsedTicks = (int) (currentTick - startTick);

        if (currentState == SequenceState.FADE_TO_ATTACK) {
            int duration = FADE_OUT_1_END_TICK - TARGETING_END_TICK; // 10틱
            int current = elapsedTicks - TARGETING_END_TICK;
            float t = MathHelper.clamp((float) current / duration, 0.0f, 1.0f);
            return t;
        }

        if (currentState == SequenceState.ATTACK_PHASE) {
            return 0.0f;
        }

        if (currentState == SequenceState.FADE_TO_RETURN) {
            int duration = FADE_OUT_2_END_TICK - ATTACK_END_TICK; // 10틱
            int current = elapsedTicks - ATTACK_END_TICK;
            float t = MathHelper.clamp((float) current / duration, 0.0f, 1.0f);
            return t;
        }

        if (currentState == SequenceState.FADE_FROM_RETURN) {
            int duration = SEQUENCE_END_TICK - FADE_OUT_2_END_TICK; // 10틱
            int current = elapsedTicks - FADE_OUT_2_END_TICK;
            float t = MathHelper.clamp((float) current / duration, 0.0f, 1.0f);
            return 1.0f - t;
        }

        return 0.0f;
    }

    public static float updateAndGetCameraPitch(float currentPitch, float tickDelta) {
        if (!isExploitActive()) {
            smoothCameraPitch = currentPitch;
            return currentPitch;
        }

        if (currentState == SequenceState.TARGETING || currentState == SequenceState.WAITING_FOR_TRIGGER || currentState == SequenceState.WAIT_FOR_UNLOCK) {
            smoothCameraPitch = currentPitch;
            return currentPitch;
        }

        MinecraftClient client = MinecraftClient.getInstance();
        ClientWorld world = client.world;
        if (world == null) return currentPitch;

        long currentTick = world.getTime();
        float elapsedTicksF = (float) (currentTick - startTick) + tickDelta;

        if (currentState == SequenceState.FADE_TO_ATTACK) {
            smoothCameraPitch = currentPitch;
        }
        else if (currentState == SequenceState.ATTACK_PHASE || currentState == SequenceState.FADE_TO_RETURN) {
            smoothCameraPitch = 0.0f;
        }
        else if (currentState == SequenceState.FADE_FROM_RETURN) {
            int startTickPhase = FADE_OUT_2_END_TICK; // 90틱
            int duration = SEQUENCE_END_TICK - FADE_OUT_2_END_TICK; // 10틱

            float progress = (elapsedTicksF - startTickPhase) / duration;
            progress = MathHelper.clamp(progress, 0.0f, 1.0f);

            smoothCameraPitch = MathHelper.lerp(progress, 90.0f, originalPitch);
        } else {
            smoothCameraPitch = currentPitch;
        }
        return smoothCameraPitch;
    }

    public static boolean isExploitActive() {
        return currentState != SequenceState.INACTIVE;
    }

    // 외부에 노출되어 skannamuModClient에서 호출됩니다.
    public static boolean isWaitingForTrigger() {
        return currentState == SequenceState.WAITING_FOR_TRIGGER;
    }
}