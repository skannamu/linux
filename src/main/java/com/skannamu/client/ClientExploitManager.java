package com.skannamu.client;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.network.ClientPlayerEntity;
import net.minecraft.client.sound.SoundManager;
import net.minecraft.client.sound.PositionedSoundInstance;
import net.minecraft.sound.SoundEvents;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.client.gl.ShaderEffect;
import net.minecraft.util.Identifier;

import java.io.IOException;
import java.util.UUID;

public class ClientExploitManager {

    private static SequenceState currentState = SequenceState.INACTIVE;
    private static long startTick = 0;
    private static int durationTicks = 0;
    private static UUID currentTargetUuid = null;
    private static float originalPitch = 0.0f;
    private static ShaderEffect exploitShader = null;
    private static ShaderEffect glitchShader = null; // 글리치 셰이더 변수 추가
    public static final Identifier EXPLOIT_SHADER_ID =
            Identifier.of("skannamu", "shaders/post/exploit_vision.json");
    public static final Identifier GLITCH_SHADER_ID =
            Identifier.of("skannamu", "shaders/post/glitch_effect.json");
    private static final int TARGETING_END_TICK = 50;
    private static final int ATTACK_START_TICK = 60;
    private static final int ATTACK_END_TICK = 80;
    private static final int RETURN_START_TICK = 90;
    private static final int SEQUENCE_END_TICK = 100;

    public enum SequenceState {
        INACTIVE,
        TARGETING,              // 열화상 시야 활성 및 움직임 제한 (0.0s ~ 2.5s)
        FADE_TO_ATTACK,         // 공격 전 암전 및 글리치 활성 (2.5s ~ 3.0s)
        ATTACK_PHASE,           // 공격 및 텔레포트 (3.0s ~ 4.0s)
        FADE_TO_RETURN,         // 복귀 전 암전 (4.0s ~ 4.5s)
        FADE_FROM_RETURN,       // 복귀 후 밝아짐 및 글리치 활성 (4.5s ~ 5.0s)
        WAIT_FOR_UNLOCK
    }

    public static void loadShader(MinecraftClient client) {
        releaseShader(); // 기존 셰이더 해제 후 시작

        try {
            exploitShader = new ShaderEffect(
                    client.getTextureManager(),
                    client.getResourceManager(),
                    client.getFramebuffer(),
                    EXPLOIT_SHADER_ID
            );
        } catch (IOException e) {
            System.err.println("[Skannamu] Failed to load exploit shader: " + EXPLOIT_SHADER_ID);
        }

        // 2. 글리치 셰이더 로드
        try {
            glitchShader = new ShaderEffect(
                    client.getTextureManager(),
                    client.getResourceManager(),
                    client.getFramebuffer(),
                    GLITCH_SHADER_ID
            );
        } catch (IOException e) {
            System.err.println("[Skannamu] Failed to load glitch shader: " + GLITCH_SHADER_ID);
        }
    }

    // 셰이더 해제 메서드
    public static void releaseShader() {
        if (exploitShader != null) {
            exploitShader.close();
            exploitShader = null;
        }
        if (glitchShader != null) {
            glitchShader.close();
            glitchShader = null;
        }
    }


    public static void startSequence(UUID targetId, int duration) {
        MinecraftClient client = MinecraftClient.getInstance();
        ClientPlayerEntity player = client.player;
        ClientWorld world = client.world;

        if (player != null && world != null) {
            startTick = world.getTime();
            durationTicks = duration;
            currentTargetUuid = targetId;
            originalPitch = player.getPitch();

            currentState = SequenceState.TARGETING;

            SoundManager soundManager = client.getSoundManager();
            soundManager.play(PositionedSoundInstance.master(
                    SoundEvents.BLOCK_REDSTONE_TORCH_BURNOUT,
                    1.0F,
                    1.0F
            ));

            if (client.currentScreen != null && client.currentScreen.getTitle().getString().contains("Terminal")) {
                client.setScreen(null);
            }
        }
    }

    public static void clientTick(MinecraftClient client) {
        if (currentState == SequenceState.INACTIVE) return;

        ClientWorld world = client.world;
        ClientPlayerEntity player = client.player;
        if (world == null || player == null) {
            endSequence();
            return;
        }

        long currentTick = world.getTime();
        int elapsedTicks = (int) (currentTick - startTick);

        if (elapsedTicks < TARGETING_END_TICK) {
            currentState = SequenceState.TARGETING;
        } else if (elapsedTicks < ATTACK_START_TICK) {
            currentState = SequenceState.FADE_TO_ATTACK;
        } else if (elapsedTicks < ATTACK_END_TICK) {
            currentState = SequenceState.ATTACK_PHASE;
        } else if (elapsedTicks < RETURN_START_TICK) {
            currentState = SequenceState.FADE_TO_RETURN;
        } else if (elapsedTicks < SEQUENCE_END_TICK) {
            currentState = SequenceState.FADE_FROM_RETURN;
        } else {
            currentState = SequenceState.WAIT_FOR_UNLOCK;
            endSequence();
        }

        if (currentState == SequenceState.FADE_FROM_RETURN) {
            int recoveryDuration = SEQUENCE_END_TICK - RETURN_START_TICK; // 10틱
            int currentRecoveryTick = elapsedTicks - RETURN_START_TICK;
            float t = Math.min(1.0f, (float) currentRecoveryTick / recoveryDuration);
            float startPitch = 90.0f; // 땅바닥을 보는 각도
            float newPitch = (1.0f - t) * startPitch + t * originalPitch;
            player.setPitch(newPitch);
        } else if (elapsedTicks >= ATTACK_START_TICK && elapsedTicks < RETURN_START_TICK) {
            player.setPitch(90.0f);
        }
    }

    public static void endSequence() {
        currentState = SequenceState.INACTIVE;
        startTick = 0;
        durationTicks = 0;
        currentTargetUuid = null;

        releaseShader(); // 시퀀스 종료 시 모든 셰이더 해제
    }

    public static float getCameraShakeAmount() {
        if (currentState != SequenceState.ATTACK_PHASE) return 0.0f;

        ClientWorld world = MinecraftClient.getInstance().world;
        if (world == null) return 0.0f;
        int elapsedTicks = (int) (world.getTime() - startTick);
        int attackTick = elapsedTicks - ATTACK_START_TICK; // 0 to 20
        float maxShake = 3.5f;
        float intensity = maxShake * 0.7f;
        float dampening = 1.0f - (float)attackTick / 20.0f * 0.3f;
        return (float) (Math.random() * intensity * dampening);
    }

    public static float getFadeAlpha() {
        if (currentState == SequenceState.INACTIVE) return 0.0f;

        ClientWorld world = MinecraftClient.getInstance().world;
        if (world == null) return 0.0f;
        int elapsedTicks = (int) (world.getTime() - startTick);

        if (currentState == SequenceState.FADE_TO_ATTACK) {
            int fadeDuration = ATTACK_START_TICK - TARGETING_END_TICK;
            int currentFadeTick = elapsedTicks - TARGETING_END_TICK;
            return Math.min(1.0f, (float) currentFadeTick / fadeDuration);

        } else if (elapsedTicks >= ATTACK_START_TICK && elapsedTicks < RETURN_START_TICK) {
            return 1.0f;

        } else if (currentState == SequenceState.FADE_FROM_RETURN) {
            int fadeDuration = SEQUENCE_END_TICK - RETURN_START_TICK;
            int currentFadeTick = elapsedTicks - RETURN_START_TICK;

            return Math.max(0.0f, 1.0f - ((float) currentFadeTick / fadeDuration));
        }

        return 0.0f;
    }
    public static SequenceState getCurrentState() {
        return currentState;
    }
    public static boolean isExploitActive() {
        return currentState != SequenceState.INACTIVE;
    }
    public static UUID getCurrentTargetUuid() {
        return currentTargetUuid;
    }
    public static ShaderEffect getExploitShader() {
        return exploitShader;
    }
    public static ShaderEffect getGlitchShader() {
        return glitchShader;
    }
}