package com.skannamu.client;

// 셰이더 관련 import는 전부 제거합니다.
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.network.ClientPlayerEntity;
import net.minecraft.client.sound.PositionedSoundInstance;
import net.minecraft.client.sound.SoundManager;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.sound.SoundEvents;
import net.minecraft.client.gui.screen.Screen; // 추가: TerminalScreen 확인을 위한 import
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.text.Text;
import java.util.UUID;

public class ClientExploitManager {

    private static SequenceState currentState = SequenceState.INACTIVE;
    private static long startTick = 0;
    private static int durationTicks = 0;
    private static UUID currentTargetUuid = null;
    private static float originalPitch = 0.0f;

    // 셰이더 관련 필드는 주석 처리
    /*
    private static PostEffectProcessor exploitShader = null;
    private static PostEffectProcessor glitchShader = null;
    public static final Identifier EXPLOIT_SHADER_ID =
            Identifier.of("skannamu", "shaders/post/exploit_vision.json");
    public static final Identifier GLITCH_SHADER_ID =
            Identifier.of("skannamu", "shaders/post/glitch_effect.json");
    */

    private static final int TARGETING_END_TICK = 50;
    private static final int ATTACK_START_TICK = 60;
    private static final int ATTACK_END_TICK = 80;
    private static final int RETURN_START_TICK = 90;
    private static final int SEQUENCE_END_TICK = 100;

    public enum SequenceState {
        INACTIVE,
        TARGETING,
        FADE_TO_ATTACK,
        ATTACK_PHASE,
        FADE_TO_RETURN,
        FADE_FROM_RETURN,
        WAIT_FOR_UNLOCK
    }

    // 셰이더 로드 관련 메서드 전부 주석 처리
    /*
    private static PostEffectPipeline loadPipeline(ResourceFactory factory, Identifier id) throws IOException, ShaderLoader.LoadException {
        // ... (원래 로직) ...
    }

    public static void loadShader(MinecraftClient client) {
        releaseShader();
        // ... (원래 로직) ...
    }

    public static void releaseShader() {
        if (exploitShader != null) {
            exploitShader.close();
            exploitShader = null;
        }
        if (glitchShader != null) {
            glitchShader.close();
            glitchShader = null;
        }
    }
    */

    public static void startSequence(UUID targetId, int duration) {
        MinecraftClient client = MinecraftClient.getInstance();
        ClientPlayerEntity player = client.player;
        ClientWorld world = client.world;

        if (player != null && world != null) {
            startTick = world.getTime();
            durationTicks = duration;
            currentTargetUuid = targetId;
            originalPitch = player.getPitch();

            currentState = SequenceState.TARGETING;

            SoundManager soundManager = client.getSoundManager();
            soundManager.play(PositionedSoundInstance.master(
                    SoundEvents.BLOCK_REDSTONE_TORCH_BURNOUT,
                    1.0F,
                    1.0F
            ));

            if (client.currentScreen != null && client.currentScreen.getTitle().getString().contains("Terminal")) {
                client.setScreen(null);
            }
        }
    }

    public static void clientTick(MinecraftClient client) {
        if (currentState == SequenceState.INACTIVE) return;

        ClientWorld world = client.world;
        ClientPlayerEntity player = client.player;
        if (world == null || player == null) {
            endSequence();
            return;
        }

        long currentTick = world.getTime();
        int elapsedTicks = (int) (currentTick - startTick);

        if (elapsedTicks < TARGETING_END_TICK) {
            currentState = SequenceState.TARGETING;
        } else if (elapsedTicks < ATTACK_START_TICK) {
            currentState = SequenceState.FADE_TO_ATTACK;
        } else if (elapsedTicks < ATTACK_END_TICK) {
            currentState = SequenceState.ATTACK_PHASE;
        } else if (elapsedTicks < RETURN_START_TICK) {
            currentState = SequenceState.FADE_TO_RETURN;
        } else if (elapsedTicks < SEQUENCE_END_TICK) {
            currentState = SequenceState.FADE_FROM_RETURN;
        } else {
            currentState = SequenceState.WAIT_FOR_UNLOCK;
            endSequence();
        }

        if (currentState == SequenceState.ATTACK_PHASE) {
            if (player.hurtTime < 9) {
                player.hurtTime = 9;
                player.maxHurtTime = 9;

            }
            player.setPitch(originalPitch);
        } else if (currentState == SequenceState.FADE_FROM_RETURN) {
            int recoveryDuration = SEQUENCE_END_TICK - RETURN_START_TICK; // 10틱 (0.5초)
            int currentRecoveryTick = elapsedTicks - RETURN_START_TICK;
            float t = Math.min(1.0f, (float) currentRecoveryTick / recoveryDuration);

            float startPitch = 90.0f;
            float newPitch = (1.0f - t) * startPitch + t * originalPitch;
            player.setPitch(newPitch);

        }
    }
    public static void endSequence() {
        currentState = SequenceState.INACTIVE;
        startTick = 0;
        durationTicks = 0;
        currentTargetUuid = null;
        // releaseShader(); // 셰이더 릴리스 제거
    }

    public static float getFadeAlpha() {
        return 0.0f;
    }

    public static SequenceState getCurrentState() {
        return currentState;
    }
    public static boolean isExploitActive() {
        return currentState != SequenceState.INACTIVE;
    }

    // 셰이더 getter 메서드 전부 제거
    /*
    public static PostEffectProcessor getExploitShader() {
        return exploitShader;
    }
    public static PostEffectProcessor getGlitchShader() {
        return glitchShader;
    }
    */
}