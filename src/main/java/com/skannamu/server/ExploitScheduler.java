package com.skannamu.server;

import com.skannamu.server.command.ExploitCommand;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents;
import net.minecraft.entity.damage.DamageSource;
import net.minecraft.entity.damage.DamageSources;
import net.minecraft.entity.damage.DamageType;
import net.minecraft.entity.effect.StatusEffectInstance;
import net.minecraft.entity.effect.StatusEffects;
import net.minecraft.network.packet.s2c.play.PositionFlag;
import net.minecraft.registry.Registry; // ⚠️ Registry import 추가
import net.minecraft.registry.RegistryKeys;
import net.minecraft.registry.entry.RegistryEntry.Reference;
import net.minecraft.server.MinecraftServer;
import net.minecraft.server.network.ServerPlayerEntity;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.text.Text;
import net.minecraft.util.math.MathHelper;
import net.minecraft.world.World;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

public class ExploitScheduler implements ServerTickEvents.EndTick {
    private static final Logger LOGGER = LoggerFactory.getLogger("skannamu-ExploitScheduler");

    private static final ConcurrentHashMap<UUID, Long> scheduledAttacks = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<UUID, double[]> originalPositions = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<UUID, UUID> attackTargets = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<UUID, Long> scheduledReturns = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<UUID, Integer> sequenceDurations = new ConcurrentHashMap<>();

    private static final int ATTACK_TICK_OFFSET = 60;
    private static final int RETURN_TICK_OFFSET = 30; // 공격 후 30틱 뒤 복귀

    public static void storeOriginalPosition(ServerPlayerEntity attacker, int duration) {
        originalPositions.put(attacker.getUuid(), new double[]{
                attacker.getX(),
                attacker.getY(),
                attacker.getZ(),
                attacker.getYaw()
        });
        sequenceDurations.put(attacker.getUuid(), duration);
        LOGGER.debug("[ExploitScheduler] Original position stored for attacker {}.", attacker.getGameProfile().getName());
    }

    public static void scheduleAttack(ServerPlayerEntity attacker, ServerPlayerEntity target) {
        long currentTick = attacker.getWorld().getTime();
        long attackTick = currentTick + ATTACK_TICK_OFFSET;

        scheduledAttacks.put(attacker.getUuid(), attackTick);
        attackTargets.put(attacker.getUuid(), target.getUuid());

        LOGGER.debug("[ExploitScheduler] Scheduled attack: attacker={}, target={}, executeTick={}",
                attacker.getGameProfile().getName(),
                target.getGameProfile().getName(),
                attackTick);
    }

    @Override
    public void onEndTick(MinecraftServer server) {
        World overworld = server.getOverworld();
        if (overworld == null) return;
        long currentTick = overworld.getTime();

        Iterator<Map.Entry<UUID, Long>> attackIter = scheduledAttacks.entrySet().iterator();
        while (attackIter.hasNext()) {
            Map.Entry<UUID, Long> entry = attackIter.next();
            UUID attackerUuid = entry.getKey();
            long scheduledTick = entry.getValue();

            if (currentTick >= scheduledTick) {
                if (performAttackPhase(server, attackerUuid)) {
                    long returnTick = scheduledTick + RETURN_TICK_OFFSET;
                    scheduledReturns.put(attackerUuid, returnTick);
                }
                attackIter.remove();
            }
        }

        Iterator<Map.Entry<UUID, Long>> returnIter = scheduledReturns.entrySet().iterator();
        while (returnIter.hasNext()) {
            Map.Entry<UUID, Long> entry = returnIter.next();
            UUID attackerUuid = entry.getKey();
            long scheduledTick = entry.getValue();

            if (currentTick >= scheduledTick) {
                performReturnPhase(server, attackerUuid);
                returnIter.remove();
                attackTargets.remove(attackerUuid);
                sequenceDurations.remove(attackerUuid);
            }
        }
    }

    private boolean performAttackPhase(MinecraftServer server, UUID attackerUuid) {
        ServerPlayerEntity attacker = server.getPlayerManager().getPlayer(attackerUuid);
        UUID targetUuid = attackTargets.get(attackerUuid);
        ServerPlayerEntity target = targetUuid != null ? server.getPlayerManager().getPlayer(targetUuid) : null;

        if (attacker == null) {
            LOGGER.debug("[ExploitScheduler] attacker not online: {}", attackerUuid);
            return false;
        }

        if (target == null || target.isDead()) {
            attacker.sendMessage(Text.literal("Exploit Failed: Target not found or already dead."), false);
            LOGGER.debug("[ExploitScheduler] target invalid: {} (attacker={})",
                    targetUuid, attacker.getGameProfile().getName());
            return false;
        }

        ServerWorld world = (ServerWorld) target.getWorld();

        double targetYaw = target.getYaw();
        double distance = 1.5;
        double targetX = target.getX() - distance * MathHelper.sin((float) (-targetYaw * ((float) Math.PI / 180F)));
        double targetZ = target.getZ() + distance * MathHelper.cos((float) (-targetYaw * ((float) Math.PI / 180F)));

        attacker.teleport(
                world,
                targetX,
                target.getY(),
                targetZ,
                Set.<PositionFlag>of(),
                target.getYaw(),
                target.getPitch(),
                true
        );

        attacker.swingHand(net.minecraft.util.Hand.MAIN_HAND);

        try {
            DamageSources damageSources = world.getDamageSources();

            DamageSource ds = damageSources.create(
                    ExploitCommand.EXPLOIT_DAMAGE_TYPE,
                    attacker
            );

            target.damage(world, ds, Float.MAX_VALUE);

        } catch (Exception e) {
            LOGGER.error("[ExploitScheduler] Failed to apply DamageType using DamageSources", e);
            attacker.sendMessage(Text.literal("Exploit Failed: Damage application error (Code 99). Check logs for details."), false);
            return false;
        }


        attacker.addStatusEffect(new StatusEffectInstance(
                StatusEffects.INVISIBILITY, 20, 0, false, false
        ));

        attacker.sendMessage(Text.literal("Exploit Backattack executed. Target neutralized."), false);
        LOGGER.info("[ExploitScheduler] Exploit executed: attacker={}, target={}",
                attacker.getGameProfile().getName(), target.getGameProfile().getName());
        return true;
    }

    private void performReturnPhase(MinecraftServer server, UUID attackerUuid) {
        ServerPlayerEntity attacker = server.getPlayerManager().getPlayer(attackerUuid);
        if (attacker == null) {
            LOGGER.debug("[ExploitScheduler] performReturnPhase: attacker offline {}", attackerUuid);
            return;
        }

        double[] originalPos = originalPositions.remove(attackerUuid);
        if (originalPos != null) {
            ServerWorld world = (ServerWorld) attacker.getWorld();
            attacker.teleport(
                    world,
                    originalPos[0],
                    originalPos[1],
                    originalPos[2],
                    Set.<PositionFlag>of(),
                    (float) originalPos[3],
                    attacker.getPitch(),
                    true
            );
        }

        attacker.addStatusEffect(new StatusEffectInstance(
                StatusEffects.INVISIBILITY, 20, 0, false, false
        ));
        attacker.sendMessage(Text.literal("Exploit Sequence Complete. Position restored and cloaking activated."), false);
        LOGGER.debug("[ExploitScheduler] Return completed for attacker {}", attacker.getGameProfile().getName());
    }
}