package com.skannamu.server;

import com.skannamu.server.command.ExploitCommand;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents;
import net.minecraft.entity.damage.DamageSource;
import net.minecraft.entity.damage.DamageType;
import net.minecraft.entity.effect.StatusEffectInstance;
import net.minecraft.entity.effect.StatusEffects;
import net.minecraft.network.packet.s2c.play.PositionFlag;
import net.minecraft.registry.Registry;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.registry.entry.RegistryEntry.Reference; // Reference import ÌïÑÏöî
import net.minecraft.server.MinecraftServer;
import net.minecraft.server.network.ServerPlayerEntity;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.text.Text;
import net.minecraft.util.math.MathHelper;
import net.minecraft.world.World;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Iterator;
import java.util.Map;
import java.util.Optional; // Optional import ÌïÑÏöî
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

public class ExploitScheduler implements ServerTickEvents.EndTick {
    private static final Logger LOGGER = LoggerFactory.getLogger("skannamu-ExploitScheduler");

    private static final ConcurrentHashMap<UUID, Long> scheduledAttacks = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<UUID, double[]> originalPositions = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<UUID, UUID> attackTargets = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<UUID, Long> scheduledReturns = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<UUID, Integer> sequenceDurations = new ConcurrentHashMap<>();

    private static final int ATTACK_TICK_OFFSET = 60;

    public static void scheduleAttack(ServerPlayerEntity attacker, ServerPlayerEntity target, int duration) {
        long currentTick = attacker.getWorld().getTime();
        long attackTick = currentTick + ATTACK_TICK_OFFSET;

        scheduledAttacks.put(attacker.getUuid(), attackTick);
        attackTargets.put(attacker.getUuid(), target.getUuid());
        sequenceDurations.put(attacker.getUuid(), duration);

        originalPositions.put(attacker.getUuid(), new double[]{
                attacker.getX(),
                attacker.getY(),
                attacker.getZ(),
                attacker.getYaw()
        });

        LOGGER.debug("[ExploitScheduler] Scheduled attack: attacker={}, target={}, executeTick={}",
                attacker.getGameProfile().getName(),
                target.getGameProfile().getName(),
                attackTick);
    }

    @Override
    public void onEndTick(MinecraftServer server) {
        World overworld = server.getOverworld();
        if (overworld == null) return;
        long currentTick = overworld.getTime();

        Iterator<Map.Entry<UUID, Long>> attackIter = scheduledAttacks.entrySet().iterator();
        while (attackIter.hasNext()) {
            Map.Entry<UUID, Long> entry = attackIter.next();
            UUID attackerUuid = entry.getKey();
            long scheduledTick = entry.getValue();

            if (currentTick >= scheduledTick) {
                if (performAttackPhase(server, attackerUuid)) {
                    long returnTick = scheduledTick + 30;
                    scheduledReturns.put(attackerUuid, returnTick);
                }
                attackIter.remove();
            }
        }

        Iterator<Map.Entry<UUID, Long>> returnIter = scheduledReturns.entrySet().iterator();
        while (returnIter.hasNext()) {
            Map.Entry<UUID, Long> entry = returnIter.next();
            UUID attackerUuid = entry.getKey();
            long scheduledTick = entry.getValue();

            if (currentTick >= scheduledTick) {
                performReturnPhase(server, attackerUuid);
                returnIter.remove();
                attackTargets.remove(attackerUuid);
                sequenceDurations.remove(attackerUuid);
            }
        }
    }

    private boolean performAttackPhase(MinecraftServer server, UUID attackerUuid) {
        ServerPlayerEntity attacker = server.getPlayerManager().getPlayer(attackerUuid);
        UUID targetUuid = attackTargets.get(attackerUuid);
        ServerPlayerEntity target = targetUuid != null ? server.getPlayerManager().getPlayer(targetUuid) : null;

        if (attacker == null) {
            LOGGER.debug("[ExploitScheduler] attacker not online: {}", attackerUuid);
            return false;
        }

        if (target == null || target.isDead()) {
            attacker.sendMessage(Text.literal("Exploit Failed: Target not found or already dead."), false);
            LOGGER.debug("[ExploitScheduler] target invalid: {} (attacker={})",
                    targetUuid, attacker.getGameProfile().getName());
            return false;
        }

        ServerWorld world = (ServerWorld) target.getWorld();

        double targetYaw = target.getYaw();
        double distance = 1.5;
        double targetX = target.getX() - distance * MathHelper.sin((float) (-targetYaw * ((float) Math.PI / 180F)));
        double targetZ = target.getZ() + distance * MathHelper.cos((float) (-targetYaw * ((float) Math.PI / 180F)));

        attacker.teleport(
                world,
                targetX,
                target.getY(),
                targetZ,
                Set.<PositionFlag>of(),
                target.getYaw(),
                target.getPitch(),
                true
        );

        attacker.swingHand(net.minecraft.util.Hand.MAIN_HAND);

        try {
            // 1. DynamicRegistryManagerÏóêÏÑú Registry<DamageType>Î•º Í∞ÄÏ†∏ÏòµÎãàÎã§.
            Registry<DamageType> damageRegistry = attacker.getWorld()
                    .getRegistryManager()
                    .getOrThrow(RegistryKeys.DAMAGE_TYPE);

            // 2. üü¢ ÏàòÏ†ïÎêú Î∂ÄÎ∂Ñ: getEntry(Identifier)Î•º ÏÇ¨Ïö©ÌïòÏó¨ DamageTypeÏùò ReferenceÎ•º Í∞ÄÏ†∏Ïò¥
            Optional<Reference<DamageType>> damageTypeReference = damageRegistry
                    .getEntry(ExploitCommand.EXPLOIT_DAMAGE_TYPE.getValue());

            // Optional<Reference>Í∞Ä ÎπÑÏñ¥ÏûàÏúºÎ©¥ ÏòàÏô∏ Î∞úÏÉù
            Reference<DamageType> damageTypeEntry = damageTypeReference
                    .orElseThrow(() -> new IllegalStateException("Exploit Damage Type not found in registry (by Identifier)."));

            // DamageSource ÏÉùÏÑ± Î∞è ÌîºÌï¥ Ï†ÅÏö©
            DamageSource ds = new DamageSource(damageTypeEntry, attacker);
            target.damage(attacker.getWorld(), ds, Float.MAX_VALUE);

        } catch (Exception e) {
            LOGGER.error("[ExploitScheduler] Failed to apply DamageType", e);
            attacker.sendMessage(Text.literal("Exploit Failed: Damage application error. Check logs for details."), false);
            return false;
        }

        attacker.addStatusEffect(new StatusEffectInstance(
                StatusEffects.INVISIBILITY, 20, 0, false, false
        ));

        attacker.sendMessage(Text.literal("Exploit Backattack executed. Target neutralized."), false);
        LOGGER.info("[ExploitScheduler] Exploit executed: attacker={}, target={}",
                attacker.getGameProfile().getName(), target.getGameProfile().getName());
        return true;
    }

    private void performReturnPhase(MinecraftServer server, UUID attackerUuid) {
        ServerPlayerEntity attacker = server.getPlayerManager().getPlayer(attackerUuid);
        if (attacker == null) {
            LOGGER.debug("[ExploitScheduler] performReturnPhase: attacker offline {}", attackerUuid);
            return;
        }

        double[] originalPos = originalPositions.remove(attackerUuid);
        if (originalPos != null) {
            ServerWorld world = (ServerWorld) attacker.getWorld();
            attacker.teleport(
                    world,
                    originalPos[0],
                    originalPos[1],
                    originalPos[2],
                    Set.<PositionFlag>of(),
                    (float) originalPos[3],
                    attacker.getPitch(),
                    true
            );
        }

        attacker.addStatusEffect(new StatusEffectInstance(
                StatusEffects.INVISIBILITY, 20, 0, false, false
        ));
        attacker.sendMessage(Text.literal("Exploit Sequence Complete. Position restored and cloaking activated."), false);
        LOGGER.debug("[ExploitScheduler] Return completed for attacker {}", attacker.getGameProfile().getName());
    }
}