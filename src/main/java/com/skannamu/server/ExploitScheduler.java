package com.skannamu.server;

import com.skannamu.network.ExploitTriggerPayload;
import com.skannamu.server.command.ExploitCommand;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents;
// import net.fabricmc.fabric.api.networking.v1.PayloadTypeRegistry; // [수정] 타입 등록 코드 제거
import net.fabricmc.fabric.api.networking.v1.ServerPlayConnectionEvents;
import net.fabricmc.fabric.api.networking.v1.ServerPlayNetworking;
import net.minecraft.entity.damage.DamageSource;
import net.minecraft.entity.damage.DamageSources;
import net.minecraft.entity.effect.StatusEffectInstance;
import net.minecraft.entity.effect.StatusEffects;
import net.minecraft.network.packet.s2c.play.PositionFlag;
import net.minecraft.server.MinecraftServer;
import net.minecraft.server.network.ServerPlayerEntity;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.text.Text;
import net.minecraft.util.math.MathHelper;
import net.minecraft.world.World;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

public class ExploitScheduler implements ServerTickEvents.EndTick {
    private static final Logger LOGGER = LoggerFactory.getLogger("skannamu-ExploitScheduler");

    private static final ConcurrentHashMap<UUID, UUID> pendingAttacks = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<UUID, double[]> originalPositions = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<UUID, Long> scheduledAttackExecution = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<UUID, Long> scheduledReturns = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<UUID, Integer> sequenceDurations = new ConcurrentHashMap<>();

    private static final int ATTACK_EXECUTION_DELAY = 10;
    private static final int RETURN_TICK_OFFSET = 30;

    public static void registerHandlers() {
        // [FIXED] ExploitTriggerPayload 타입 등록 코드를 제거했습니다.
        // 이 코드는 skannamuMod.java에서만 호출되도록 변경되었습니다.
        // PayloadTypeRegistry.playC2S().register(ExploitTriggerPayload.ID, ExploitTriggerPayload.CODEC);


        // [ACTION] ExploitTriggerPayload 핸들러 등록
        ServerPlayNetworking.registerGlobalReceiver(ExploitTriggerPayload.ID, (payload, context) -> {
            UUID attackerUuid = payload.attackerUuid();
            UUID targetUuid = payload.targetUuid();
            MinecraftServer server = context.server();
            // 서버 메인 스레드에서 공격 예약 실행
            server.execute(() -> performTriggeredAttack(server, attackerUuid, targetUuid));
        });

        // [ACTION] 연결 끊김 이벤트 핸들러 등록
        ServerPlayConnectionEvents.DISCONNECT.register((handler, server) -> {
            UUID playerId = handler.player.getUuid();
            pendingAttacks.remove(playerId);
            scheduledAttackExecution.remove(playerId);
            scheduledReturns.remove(playerId);
            originalPositions.remove(playerId);
            sequenceDurations.remove(playerId);
        });
    }

    public static void storeOriginalPosition(ServerPlayerEntity attacker, int duration) {
        originalPositions.put(attacker.getUuid(), new double[]{
                attacker.getX(),
                attacker.getY(),
                attacker.getZ(),
                attacker.getYaw()
        });
        sequenceDurations.put(attacker.getUuid(), duration);
        LOGGER.debug("[ExploitScheduler] Original position stored for attacker {}.", attacker.getGameProfile().getName());
    }

    public static void storePendingAttack(UUID attackerUuid, UUID targetUuid) {
        pendingAttacks.put(attackerUuid, targetUuid);
        LOGGER.debug("[ExploitScheduler] Pending attack stored: attacker={}, target={}",
                attackerUuid, targetUuid);
    }

    private static void performTriggeredAttack(MinecraftServer server, UUID attackerUuid, UUID targetUuid) {
        if (!pendingAttacks.containsKey(attackerUuid)) {
            LOGGER.warn("[ExploitScheduler] Received unexpected trigger for non-pending attacker: {}", attackerUuid);
            return;
        }

        ServerPlayerEntity attacker = server.getPlayerManager().getPlayer(attackerUuid);
        if (attacker == null) {
            LOGGER.debug("[ExploitScheduler] Triggered attacker not online: {}", attackerUuid);
            return;
        }

        // 트리거 수신 시점 (T~50)에서 10틱 후 (T=60)에 공격 실행을 예약합니다.
        long currentTick = attacker.getWorld().getTime();
        long attackTick = currentTick + ATTACK_EXECUTION_DELAY;
        scheduledAttackExecution.put(attackerUuid, attackTick);

        LOGGER.debug("[ExploitScheduler] Attack scheduled for tick: {} (Target: {})", attackTick, targetUuid);
    }

    @Override
    public void onEndTick(MinecraftServer server) {
        World overworld = server.getOverworld();
        if (overworld == null) return;
        long currentTick = overworld.getTime();

        // 1. 공격 실행 스케줄러 처리
        Iterator<Map.Entry<UUID, Long>> attackIter = scheduledAttackExecution.entrySet().iterator();
        while (attackIter.hasNext()) {
            Map.Entry<UUID, Long> entry = attackIter.next();
            UUID attackerUuid = entry.getKey();
            long scheduledTick = entry.getValue();

            if (currentTick >= scheduledTick) {
                UUID targetUuid = pendingAttacks.remove(attackerUuid);

                if (targetUuid != null) {
                    performAttackPhase(server, attackerUuid, targetUuid);

                    if (originalPositions.containsKey(attackerUuid)) {
                        // 공격 후 복귀 예약 (ATTACK_EXECUTION_DELAY + RETURN_TICK_OFFSET)
                        long returnTick = currentTick + RETURN_TICK_OFFSET;
                        scheduledReturns.put(attackerUuid, returnTick);
                        LOGGER.debug("[ExploitScheduler] Return scheduled for tick: {}", returnTick);
                    }
                }
                attackIter.remove(); // scheduledAttackExecution 맵에서 제거
            }
        }

        // 2. 복귀 스케줄러 처리
        Iterator<Map.Entry<UUID, Long>> returnIter = scheduledReturns.entrySet().iterator();
        while (returnIter.hasNext()) {
            Map.Entry<UUID, Long> entry = returnIter.next();
            UUID attackerUuid = entry.getKey();
            long scheduledTick = entry.getValue();

            if (currentTick >= scheduledTick) {
                performReturnPhase(server, attackerUuid);
                returnIter.remove();

                // 최종 정리
                originalPositions.remove(attackerUuid);
                sequenceDurations.remove(attackerUuid);
            }
        }
    }

    private static void performAttackPhase(MinecraftServer server, UUID attackerUuid, UUID targetUuid) {
        ServerPlayerEntity attacker = server.getPlayerManager().getPlayer(attackerUuid);
        ServerPlayerEntity target = targetUuid != null ? server.getPlayerManager().getPlayer(targetUuid) : null;

        if (attacker == null) {
            LOGGER.debug("[ExploitScheduler] attacker not online: {}", attackerUuid);
            return;
        }

        if (target == null || target.isDead()) {
            // 공격 실패 메시지
            attacker.sendMessage(Text.literal("Exploit Failed: Target not found or already dead. Returning to start position in 3 seconds."), false);
            LOGGER.debug("[ExploitScheduler] target invalid: {} (attacker={})",
                    targetUuid, attacker.getGameProfile().getName());
            return;
        }

        ServerWorld world = (ServerWorld) target.getWorld();

        // 타겟의 등 뒤 포지션 계산 (Teleport to target's back)
        double targetYaw = target.getYaw();
        double distance = 2.0;

        float yawRad = (float) (targetYaw * Math.PI / 180.0F);

        // 등 뒤 포지션 계산 (Back X: +sin, Back Z: -cos)
        double targetX = target.getX() + distance * MathHelper.sin(yawRad);
        double targetZ = target.getZ() - distance * MathHelper.cos(yawRad);

        // 순간이동: 위치(X,Y,Z)와 회전(YAW, PITCH) 모두 절대값으로 텔레포트합니다.
        attacker.teleport(
                world,
                targetX,
                target.getY(),
                targetZ,
                Set.<PositionFlag>of(),
                target.getYaw(), // Attacker faces the same direction as the target
                target.getPitch(),
                true
        );

        // 공격 모션 표시
        attacker.swingHand(net.minecraft.util.Hand.MAIN_HAND);

        try {
            DamageSources damageSources = world.getDamageSources();

            DamageSource ds = damageSources.create(
                    ExploitCommand.EXPLOIT_DAMAGE_TYPE,
                    attacker
            );

            // 즉사 공격 데미지 적용
            target.damage(world, ds, Float.MAX_VALUE);

        } catch (Exception e) {
            LOGGER.error("[ExploitScheduler] Failed to apply DamageType using DamageSources", e);
            attacker.sendMessage(Text.literal("Exploit Failed: Damage application error (Code 99). Check logs for details. Returning to start position in 3 seconds."), false);
            return;
        }

        // 공격 후 은신 효과 적용 (1초) - 암전 상태에서 페이드 아웃 효과를 보조
        attacker.addStatusEffect(new StatusEffectInstance(
                StatusEffects.INVISIBILITY, 20, 0, false, false
        ));

        attacker.sendMessage(Text.literal("Exploit Backattack executed. Target neutralized."), false);
        LOGGER.info("[ExploitScheduler] Exploit executed: attacker={}, target={}",
                attacker.getGameProfile().getName(), target.getGameProfile().getName());
    }

    private void performReturnPhase(MinecraftServer server, UUID attackerUuid) {
        ServerPlayerEntity attacker = server.getPlayerManager().getPlayer(attackerUuid);
        if (attacker == null) {
            LOGGER.debug("[ExploitScheduler] performReturnPhase: attacker offline or not found {}", attackerUuid);
            return;
        }

        // 원본 위치 정보 조회 및 사용
        double[] originalPos = originalPositions.get(attackerUuid);
        if (originalPos != null) {
            ServerWorld world = (ServerWorld) attacker.getWorld();

            // 순간이동: 원본 위치와 Yaw로 절대 텔레포트하여 복귀
            attacker.teleport(
                    world,
                    originalPos[0],
                    originalPos[1],
                    originalPos[2],
                    Set.<PositionFlag>of(),
                    (float) originalPos[3],
                    attacker.getPitch(),
                    true
            );
        }

        // 복귀 후 은신 효과 적용 (1초) - 최종 페이드 아웃 효과 보조
        attacker.addStatusEffect(new StatusEffectInstance(
                StatusEffects.INVISIBILITY, 20, 0, false, false
        ));
        attacker.sendMessage(Text.literal("Exploit Sequence Complete. Position restored and cloaking activated."), false);
        LOGGER.debug("[ExploitScheduler] Return completed for attacker {}", attacker.getGameProfile().getName());
    }
}