package com.skannamu.server;

import com.skannamu.network.ExploitTriggerPayload;
import com.skannamu.network.HackedStatusPayload; // üí° Ïã†Í∑ú ÏûÑÌè¨Ìä∏
import com.skannamu.server.command.ExploitCommand;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents;
import net.fabricmc.fabric.api.networking.v1.ServerPlayConnectionEvents;
import net.fabricmc.fabric.api.networking.v1.ServerPlayNetworking;
import net.minecraft.entity.damage.DamageSource;
import net.minecraft.entity.damage.DamageSources;
import net.minecraft.entity.effect.StatusEffectInstance;
import net.minecraft.entity.effect.StatusEffects;
import net.minecraft.network.packet.s2c.play.PositionFlag;
import net.minecraft.server.MinecraftServer;
import net.minecraft.server.network.ServerPlayerEntity;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.text.Text;
import net.minecraft.util.math.MathHelper;
import net.minecraft.world.World;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

public class ExploitScheduler implements ServerTickEvents.EndTick {
    private static final Logger LOGGER = LoggerFactory.getLogger("skannamu-ExploitScheduler");

    private static final ConcurrentHashMap<UUID, UUID> pendingAttacks = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<UUID, double[]> originalPositions = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<UUID, Long> scheduledAttackExecution = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<UUID, Long> scheduledReturns = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<UUID, Integer> sequenceDurations = new ConcurrentHashMap<>();

    private static final int ATTACK_EXECUTION_DELAY = 10;
    private static final int RETURN_TICK_OFFSET = 30;

    public static void registerHandlers() {

        ServerPlayNetworking.registerGlobalReceiver(ExploitTriggerPayload.ID, (payload, context) -> {
            UUID attackerUuid = payload.attackerUuid();
            UUID targetUuid = payload.targetUuid();
            MinecraftServer server = context.server();
            server.execute(() -> performTriggeredAttack(server, attackerUuid, targetUuid));
        });

        ServerPlayConnectionEvents.DISCONNECT.register((handler, server) -> {
            UUID playerId = handler.player.getUuid();
            pendingAttacks.remove(playerId);
            scheduledAttackExecution.remove(playerId);
            scheduledReturns.remove(playerId);
            originalPositions.remove(playerId);
            sequenceDurations.remove(playerId);
        });
    }

    public static void storeOriginalPosition(ServerPlayerEntity attacker, int duration) {
        originalPositions.put(attacker.getUuid(), new double[]{
                attacker.getX(),
                attacker.getY(),
                attacker.getZ(),
                attacker.getYaw()
        });
        sequenceDurations.put(attacker.getUuid(), duration);
        LOGGER.debug("[ExploitScheduler] Original position stored for attacker {}.", attacker.getGameProfile().getName());
    }

    public static void storePendingAttack(UUID attackerUuid, UUID targetUuid) {
        pendingAttacks.put(attackerUuid, targetUuid);
        LOGGER.debug("[ExploitScheduler] Pending attack stored: attacker={}, target={}",
                attackerUuid, targetUuid);
    }

    private static void performTriggeredAttack(MinecraftServer server, UUID attackerUuid, UUID targetUuid) {
        if (!pendingAttacks.containsKey(attackerUuid)) {
            LOGGER.warn("[ExploitScheduler] Received unexpected trigger for non-pending attacker: {}", attackerUuid);
            return;
        }

        ServerPlayerEntity attacker = server.getPlayerManager().getPlayer(attackerUuid);
        if (attacker == null) {
            LOGGER.debug("[ExploitScheduler] Triggered attacker not online: {}", attackerUuid);
            return;
        }

        long currentTick = attacker.getWorld().getTime();
        long attackTick = currentTick + ATTACK_EXECUTION_DELAY;
        scheduledAttackExecution.put(attackerUuid, attackTick);

        LOGGER.debug("[ExploitScheduler] Attack scheduled for tick: {} (Target: {})", attackTick, targetUuid);
    }

    @Override
    public void onEndTick(MinecraftServer server) {
        World overworld = server.getOverworld();
        if (overworld == null) return;
        long currentTick = overworld.getTime();

        Iterator<Map.Entry<UUID, Long>> attackIter = scheduledAttackExecution.entrySet().iterator();
        while (attackIter.hasNext()) {
            Map.Entry<UUID, Long> entry = attackIter.next();
            UUID attackerUuid = entry.getKey();
            long scheduledTick = entry.getValue();

            if (currentTick >= scheduledTick) {
                UUID targetUuid = pendingAttacks.remove(attackerUuid);

                if (targetUuid != null) {
                    performAttackPhase(server, attackerUuid, targetUuid);

                    if (originalPositions.containsKey(attackerUuid)) {
                        long returnTick = currentTick + RETURN_TICK_OFFSET;
                        scheduledReturns.put(attackerUuid, returnTick);
                        LOGGER.debug("[ExploitScheduler] Return scheduled for tick: {}", returnTick);
                    }
                }
                attackIter.remove();
            }
        }

        Iterator<Map.Entry<UUID, Long>> returnIter = scheduledReturns.entrySet().iterator();
        while (returnIter.hasNext()) {
            Map.Entry<UUID, Long> entry = returnIter.next();
            UUID attackerUuid = entry.getKey();
            long scheduledTick = entry.getValue();

            if (currentTick >= scheduledTick) {
                performReturnPhase(server, attackerUuid);
                returnIter.remove();

                originalPositions.remove(attackerUuid);
                sequenceDurations.remove(attackerUuid);
            }
        }
        for (ServerPlayerEntity player : server.getPlayerManager().getPlayerList()) {
            ServerCommandProcessor.PlayerState state = ServerCommandProcessor.getPlayerState(player.getUuid());

            if (state.isHacked() && currentTick >= state.getHackedUntilTick()) {
                state.setHacked(false, 0, server);

                HackedStatusPayload payload = new HackedStatusPayload(false);
                ServerPlayNetworking.send(player, payload);

                player.sendMessage(Text.literal("‚úÖ Terminal system online. EMP effect dissipated."), true);
                LOGGER.debug("[ExploitScheduler] Hacked status removed for {}", player.getGameProfile().getName());
            }
        }
    }

    private static void performAttackPhase(MinecraftServer server, UUID attackerUuid, UUID targetUuid) {
        ServerPlayerEntity attacker = server.getPlayerManager().getPlayer(attackerUuid);
        ServerPlayerEntity target = targetUuid != null ? server.getPlayerManager().getPlayer(targetUuid) : null;

        if (attacker == null) {
            LOGGER.debug("[ExploitScheduler] attacker not online: {}", attackerUuid);
            return;
        }

        if (target == null || target.isDead()) {
            attacker.sendMessage(Text.literal("Exploit Failed: Target not found or already dead. Returning to start position in 3 seconds."), false);
            LOGGER.debug("[ExploitScheduler] target invalid: {} (attacker={})",
                    targetUuid, attacker.getGameProfile().getName());
            return;
        }

        ServerWorld world = (ServerWorld) target.getWorld();

        double targetYaw = target.getYaw();
        double distance = 2.0;
        float yawRad = (float) (targetYaw * Math.PI / 180.0F);
        double targetX = target.getX() + distance * MathHelper.sin(yawRad);
        double targetZ = target.getZ() - distance * MathHelper.cos(yawRad);

        attacker.teleport(
                world,
                targetX,
                target.getY(),
                targetZ,
                Set.<PositionFlag>of(),
                target.getYaw(),
                target.getPitch(),
                true
        );

        attacker.swingHand(net.minecraft.util.Hand.MAIN_HAND);

        try {
            DamageSources damageSources = world.getDamageSources();

            DamageSource ds = damageSources.create(
                    ExploitCommand.EXPLOIT_DAMAGE_TYPE,
                    attacker
            );

            target.damage(world, ds, Float.MAX_VALUE);

        } catch (Exception e) {
            LOGGER.error("[ExploitScheduler] Failed to apply DamageType using DamageSources", e);
            attacker.sendMessage(Text.literal("Exploit Failed: Damage application error (Code 99). Check logs for details. Returning to start position in 3 seconds."), false);
            return;
        }

        attacker.addStatusEffect(new StatusEffectInstance(
                StatusEffects.INVISIBILITY, 20, 0, false, false
        ));
        attacker.sendMessage(Text.literal("Exploit Backattack executed. Target neutralized."), false);
        LOGGER.info("[ExploitScheduler] Exploit executed: attacker={}, target={}",
                attacker.getGameProfile().getName(), target.getGameProfile().getName());
    }
    private void performReturnPhase(MinecraftServer server, UUID attackerUuid) {
        ServerPlayerEntity attacker = server.getPlayerManager().getPlayer(attackerUuid);
        if (attacker == null) {
            LOGGER.debug("[ExploitScheduler] performReturnPhase: attacker offline or not found {}", attackerUuid);
            return;
        }
        double[] originalPos = originalPositions.get(attackerUuid);
        if (originalPos != null) {
            ServerWorld world = (ServerWorld) attacker.getWorld();
            attacker.teleport(
                    world,
                    originalPos[0],
                    originalPos[1],
                    originalPos[2],
                    Set.<PositionFlag>of(),
                    (float) originalPos[3],
                    attacker.getPitch(),
                    true
            );
        }
        attacker.addStatusEffect(new StatusEffectInstance(
                StatusEffects.INVISIBILITY, 20, 0, false, false
        ));
        attacker.sendMessage(Text.literal("Exploit Sequence Complete. Position restored and cloaking activated."), false);
        LOGGER.debug("[ExploitScheduler] Return completed for attacker {}", attacker.getGameProfile().getName());
    }
}